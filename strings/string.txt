//reversal of string
void reverseStr(string& str) 
{ 
    int n = str.length(); 
  
    // Swap character starting from two 
    // corners 
    for (int i = 0; i < n / 2; i++) 
        swap(str[i], str[n - i - 1]); 
} 


//permutation of all string
void permute(string a, int l, int r)  
{  
    // Base case  
    if (l == r)  
        cout<<a<<endl;  
    else
    {  
        // Permutations made  
        for (int i = l; i <= r; i++)  
        {  
  
            // Swapping done  
            swap(a[l], a[i]);  
  
            // Recursion called  
            permute(a, l+1, r);  
  
            //backtrack  
            swap(a[l], a[i]);  
        }  
    }  
} 


//longest palindrome in a string
int longestPalSubstr(char *str)  
{  
    int maxLength = 1; // The result (length of LPS)  
  
    int start = 0;  
    int len = strlen(str);  
  
    int low, high;  
  
    // One by one consider every character as center point of  
    // even and length palindromes  
    for (int i = 1; i < len; ++i)  
    {  
        // Find the longest even length palindrome  
        // with center points as i-1 and i.  
        low = i - 1;  
        high = i;  
        while (low >= 0 && high < len && str[low] == str[high])  
        {  
            if (high - low + 1 > maxLength)  
            {  
                start = low;  
                maxLength = high - low + 1;  
            }  
            --low;  
            ++high;  
        }  
  
        // Find the longest odd length palindrome with center  
        // point as i  
        low = i - 1;  
        high = i + 1;  
        while (low >= 0 && high < len && str[low] == str[high])  
        {  
            if (high - low + 1 > maxLength)  
            {  
                start = low;  
                maxLength = high - low + 1;  
            }  
            --low;  
            ++high;  
        }  
    }  
  
    cout<<"Longest palindrome substring is: ";  
    printSubStr(str, start, start + maxLength - 1);  
  
    return maxLength;  
}  
//recursively remove all adjacent duplicates
char* removeUtil(char *str, char *last_removed) 
{ 
    // If length of string is 1 or 0 
    if (str[0] == '\0' || str[1] == '\0') 
        return str; 
  
    // Remove leftmost same characters and recur for remaining  
    // string 
    if (str[0] == str[1]) 
    { 
        *last_removed = str[0]; 
        while (str[1] && str[0] == str[1]) 
            str++; 
        str++; 
        return removeUtil(str, last_removed); 
    } 
  
    // At this point, the first character is definiotely different  
    // from its adjacent. Ignore first character and recursively  
    // remove characters from remaining string 
    char* rem_str = removeUtil(str+1, last_removed); 
  
    // Check if the first character of the rem_string matches with  
    // the first character of the original string 
    if (rem_str[0] && rem_str[0] == str[0]) 
    { 
        *last_removed = str[0]; 
        return (rem_str+1); // Remove first character 
    } 
  
    // If remaining string becomes empty and last removed character 
    // is same as first character of original string. This is needed 
    // for a string like "acbbcddc" 
    if (rem_str[0] == '\0' && *last_removed == str[0]) 
        return rem_str; 
  
    // If the two first characters of str and rem_str don't match,  
    // append first character of str before the first character of 
    // rem_str.  
    rem_str--; 
    rem_str[0] = str[0]; 
    return rem_str; 
} 